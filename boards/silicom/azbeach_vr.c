/*
 * Copyright (c) 2023 Silicom Connectivity Solutions, Ltd.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <soc.h>
#include <zephyr/device.h>
#include <errno.h>
#include <zephyr/drivers/i2c.h>
#include <zephyr/sys/util.h>
#include "i2c_hub.h"
#include <zephyr/logging/log.h>
#include "board.h"
#include "board_config.h"
#include "azbeach_mec172x.h"

LOG_MODULE_DECLARE(board, CONFIG_BOARD_LOG_LEVEL);

const struct device *i2c = DEVICE_DT_GET(DT_NODELABEL(i2c_smb_0));

static uint16_t vr_program[] = {
	0x00,   0x00, 0x07, 0x0000, 0x0A, 0x0000,
	0x0B, 0x0000, 0x1A, 0x0C00, 0x1B, 0x0065, 0x1D, 0x6090,
	0x1E, 0x0000, 0x1F, 0x4000, 0x21, 0x0083, 0x22, 0x0000,
	0x23, 0x0000, 0x24, 0x00FF, 0x25, 0x0083, 0x26, 0x000B,
	0x27, 0x0000, 0x28, 0x0010, 0x29, 0x0002, 0x2A, 0x0000,
	0x2B, 0x0393, 0x2C, 0x0356, 0x2D, 0x000A, 0x2E, 0x0FC3,
	0x2F, 0xA1EF, 0x30, 0x2539, 0x31, 0x0157, 0x32, 0x1DFA,
	0x33, 0xFF15, 0x34, 0x7F5D, 0x35, 0x002C, 0x36, 0x0028,
	0x37, 0x028A, 0x38, 0x0045, 0x39, 0xE8FA, 0x3A, 0x003C,
	0x3B, 0x0064, 0x3C, 0x00D1, 0x3D, 0x2BC3, 0x3E, 0x130F,
	0x3F, 0xE081, 0x40, 0x02FA, 0x41, 0x013F, 0x42, 0x00FA,
	0x43, 0x001E, 0x44, 0x003F, 0x45, 0x003F, 0x46, 0x0099,
	0x47, 0x0002, 0x48, 0x0115, 0x49, 0x0000, 0x4A, 0x1734,
	0x4B, 0x06E2, 0x4C, 0x01C3, 0x4D, 0xE0EC, 0x4E, 0x0001,
	0x4F, 0x0020, 0x50, 0x0000, 0x52, 0x0030, 0x53, 0x0035,
	0x54, 0xF680, 0x55, 0x0037, 0x60, 0x46B0, 0x61, 0x0059,
	0x62, 0x0CA2, 0x90, 0xEEBC, 0x91, 0x7178, 0x92, 0x2564,
	0x93, 0x0024, 0x94, 0x0001, 0x95, 0x497A, 0x96, 0x3005,
	0x97, 0x0181, 0x98, 0x0081, 0x99, 0x0002, 0xA0, 0x0005,
	0xA1, 0x0014, 0xA2, 0x0285, 0xA3, 0x0007, 0xB0, 0x14A5,
	0xB1, 0x14A5, 0xB2, 0x0005, 0xB3, 0x14A0, 0xBB, 0x0020,
	0xBC, 0x0069, 0xBD, 0x000D, 0xC0, 0x00A0, 0xC1, 0x2A80,
	0xC2, 0x4B1E, 0xD2, 0x0099, 0xD3, 0x0002, 0xD4, 0x0048,
	0xD5, 0x0007, 0xD6, 0x002D, 0xD7, 0x000C, 0xD8, 0x0020,
	0xD9, 0x0012, 0xE0, 0x000B, 0xE1, 0x0006, 0xE2, 0x0099,
	0xE3, 0x0003, 0xE4, 0x0000, 0xE5, 0x0000, 0xE7, 0x0000, 
	0xE8, 0x00A7, 0xE9, 0x00A7, 0xEA, 0x00A7, 0xEB, 0x00A7,
       	0xEF, 0x00EC, 0xF0, 0x00EC, 0xF1, 0xC40A, 0xF2, 0x00CD,
       	0xF3, 0x0058, 0xF4, 0x0080, 0xF5, 0x0AA0, 0xF6, 0x0002,
       	0x00,   0x01, 0x1B, 0x0065, 0x1F, 0x4000, 0x21, 0x0083, 
	0x22, 0x0000, 0x23, 0x0000, 0x24, 0x00FF, 0x25, 0x0083, 
	0x26, 0x000B, 0x27, 0x00A1, 0x28, 0x0010, 0x29, 0x0001,
       	0x2B, 0x0393, 0x2C, 0x02AC, 0x2E, 0x0FC3, 0x30, 0x243B,
       	0x31, 0x0157, 0x32, 0x1DFA, 0x33, 0xFF15, 0x34, 0x005D,
       	0x37, 0x028A, 0x38, 0x0023, 0x39, 0xE8F8, 0x3A, 0x003C,
       	0x3B, 0x0064, 0x3C, 0x00D1, 0x3D, 0x2BC3, 0x3E, 0x000F,
       	0x3F, 0xE081, 0x40, 0x02FA, 0x41, 0x013F, 0x42, 0x00FA,
       	0x43, 0x001E, 0x44, 0x003F, 0x45, 0x003F, 0x46, 0x0099,
       	0x47, 0x0002, 0x48, 0x00C0, 0x49, 0x0000, 0x4A, 0x0734,
       	0x4B, 0x0AE2, 0x4C, 0x01C3, 0x4D, 0xE0EC, 0x4E, 0x0001, 
	0x4F, 0x0020, 0x52, 0x0002, 0x53, 0x0013, 0x54, 0xF6C0,
	0x55, 0x0037, 0x60, 0x14B0, 0x61, 0x0059, 0x62, 0x0C91,
       	0x95, 0x497A, 0x96, 0x3005, 0x97, 0x0181, 0xA3, 0x0007,
       	0xB0, 0x14A5
};

static int vr_programmed(uint16_t addr, uint8_t page, uint8_t *reg, uint16_t expected)
{
	int ret;
	uint8_t write_word[2];
	uint16_t read_word;

	write_word[0] = 0;
	write_word[1] = page;

	ret = i2c_write(i2c, write_word, 3, addr);
	LOG_INF("%s writing page %d", __func__, page);

	ret = i2c_write_read(i2c, addr, reg, 1, &read_word, 2);
	LOG_INF("%s read reg 0x%x, actual 0x%x expected 0x%x", __func__, *reg, read_word, expected);

	if (!ret && (read_word != expected))
		return 0;
	else
		return 1;
}

void vr_check_and_program()
{
	char cmd = 0x15;
	int ret;
	uint16_t data;
	uint8_t check_reg = 0x27;

	gpio_write_pin(EC_CORE_SA_PE, GPIO_OUTPUT_HIGH);
	k_sleep(K_MSEC(1));
	if (!vr_programmed(0x20, 1, &check_reg, 0x00A1)) {
#if 1
		gpio_write_pin(ALL_SYS_PWRGD, GPIO_OUTPUT_LOW);
		k_sleep(K_MSEC(1));
		for (int i = 0; i < ARRAY_SIZE(vr_program);  i+=2) {
			switch (vr_program[i]) {
				case 0:
				case 1:
				ret = i2c_reg_write_byte(i2c, 0x20, vr_program[i], (uint8_t)vr_program[i+1]);
				break;
				default:
				data = vr_program[i+1];
				ret = i2c_burst_write(i2c, 0x20, vr_program[i], (uint8_t *)&data, 2);
				break;
			}
			LOG_INF("%s: Writing 0x%x to VR address 0x%x", __func__, vr_program[i+1], vr_program[i]);
		}
		ret = i2c_reg_write_byte(i2c, 0x20, 1, 0x80); 	// operational
		ret = i2c_reg_write_byte(i2c, 0x20, 0, 0);	// page 0 select
		ret = i2c_reg_write_byte(i2c, 0x20, 1, 0x80); 	// operational

		ret = i2c_write(i2c, &cmd, 1, 0x20);
		gpio_write_pin(ALL_SYS_PWRGD, GPIO_OUTPUT_HIGH);
#endif
	}
	gpio_write_pin(EC_CORE_SA_PE, GPIO_OUTPUT_LOW);
}
